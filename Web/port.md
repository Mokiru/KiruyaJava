# port 端口

## 常见端口

- mysql 缺省 用的 3306 端口
- redis 6379 端口
- tomcat 默认的 8080端口
- ssh的 22 端口

web相关的端口涉及的主要为80和443两个端口。

## 端口是必须的吗

在本地web开发调试过程中，我们可能都碰到过端口，比如8080端口，一般我们会去这样访问本地的web程序`localhost:8080`。

但一旦web程序部署到了正式的网站中，端口似乎就消失了，正式的网址中就不需要端口了吗？当然不是，这里起作用的是缺省值。

比如[https://baidu.com](https://baidu.com)这个url中似乎没有端口，但其实是有的，它有一个默认值443，所以完整形式实际是这样的[https://baidu.com:443](https://baidu.comn:443)，![alt text](../图片/Web/远程地址.png)。可以看到，ip地址后面跟着一个443。

如果你输入一个错误的端口，比如80，像这样[https://baidu.com:80](https://baidu.com:80)，结果就是无法访问。

但是如果你改成[http://baidu.com:80](http://baidu.com:80)，它又可以访问了。http的默认端口是80，服务器配置了http自动跳转https的301重定向，所以最终浏览器会再次跳转1到[https://baidu.com:443](https://baidu.comn:443)。

## 协议的缺省端口

当你没有显式的在url中输入端口时，浏览器实际上会根据所用的协议来为你指定一个缺省端口：
- 如果是http协议，就使用80端口。
- 如果是https协议，就使用443端口。

比如上面的用了http却输入了443，或者用了https却输入了80，就无法成功访问了。

另外，如果胡乱地输入了一个比如9999，[https://baidu.com:9999](https://baidu.com:9999)，自然也是无法访问的，原因也很简单，因为服务器上根本没有在9999端口上进行监听。

## 为什么需要端口

### 进程间通讯(IPC InterProcess Communication)

你在浏览器地址栏输入某个网站的域名，然后回车，就生成了一次请求，然后服务器响应你的请求，浏览器再把结果渲染出来，你就能最终看到一个网页。

如果你曾经ping过一个域名，比如`ping baidu.com`，比你就可以得到一个ip地址：

![alt text](../图片/Web/ping.png)

有了ip，浏览器自然就可以找到相应的host（主机），但是还有一个问题，就是一个host上运行着许多进程，如web服务，可能还有ftp服务，mysql服务等等。

简单地讲，如果一个请求只有ip地址这一信息，操作系统将不知道把这个请求交给哪个进程去处理。

所谓的一次请求，从一个比较底层的角度去看，就是一次进程间的通讯。

本地主机的 win10系统进程，可以是navicat客户端与mysql数据库服务的一次通讯，也可以是winScp客户端与vsftpd FTP服务的一次通讯等等。

所谓的端口可以简单地视作为进程ID。也即是说，如果仅有域名（ip），是无法定位到一个进程的，通讯二点发起方不但需要给出ip，还需要给出端口，只有这样，服务器才能知道由哪个进程去响应。

### 端口，一个间接层

那么问题来了，为什么引入端口，而不是直接使用进程ID呢？

1. 作为客户端无法知道服务器端对应进程的ID
2. 服务器端对应进程重启过后ID会改变
3. 一个网站的web进程ID是这个，另一个网站的可能又是另一个

自然，原因是很多的，上面只是列举了一些，而为了解决这个问题，就引入了端口这个 间接层（indirection）。

如果没有这个间接层，客户端要与服务端通讯，就要知道服务端对应进程的ID，也即是客户端是依赖于服务端的。

而有了端口这一间接层，对于web的情形，这种依赖被倒置了，客户端总是把请求发送到80（或443）端口，这些成为标准的一部分，并要求服务端反过来去适应，服务端去监听端口的通讯并处理，变成了一种反向依赖。

如果一个进程想要提供web服务，它启动之后就要去绑定（binding）web相关的端口。
> 如果端口已经被其它进程绑定了（即占用了），就会绑定失败；又或者被自身前一个未完全退出的进程占据着，也会绑定失败，在开发过程中可能会遇到类似的问题，一个web进程没有关闭，你又试图启动另一个，而两者都用了相同的端口，就会产生冲突。

并在其上持续的监听（listen），同时在有请求到来的时候去响应（response），这样一来，进程ID的问题就消解了：
> 这类似于一个接口回调，浏览器只需要面向接口索取服务，而无需知道接口服务的具体提供者，这些细节被端口层所封装并隐藏起来了。

端口这一间接层的存在解耦（decouple）了客户端与服务器端之间的强依赖，整个体系变的很灵活。
> 可以把端口视作一般编程概念中的接口（interface），而像Nginx、apache、tomcat等等可以认为是这个接口的不同实现（implementation）

### 端口与名称服务（naming service）

广义上讲，端口层也可以视作一个naming service（名称服务），这与比如springboot中的eureka里的机制本质上是一样的，只是这个name就是一个抽象的数字，比如80，就代表了一个web服务，Nginx之类的web server 绑定并监听就相当于把自身提供的web服务注册于其上。
> DNS域名系统其实也是naming service，你通过[https://baidu.com](https://baidu.com)这个名字，就能获取到我所提供的网页服务，类似的还有java里的JNDI等，把一个名字与一个服务关联起来。比如一个名字就代表一个数据源（数据库连接）之类的。

### 端口与IoC（控制反转）

广义上，端口的上述机制也是控制反转（IoC Inversion of Control）思想的一种体现，如果客户端需要知道服务端的进程ID，实际上就被服务端控制了，毕竟**服务端在哪个ID上提供服务，你就得把你的请求发到相应的ID上**。

而有了端口这一中间层，作为客户端，总是把请求发到对应端口上，并要求服务端绑定并监听那些端口以及作出响应，服务端是反过来被客户端所控制，客户端发到哪个端口，服务端就要去相应端口上监听并响应。

因为浏览器总是把web请求发送到80或者443端口，这就要求一个web server进程去监听这些端口，比如一个服务器上，web server是Nginx，它启动之后就会去监听80和443端口，任何想要访问我的主页的人，并不需要知道我的Nginx进程ID是啥，借助于端口这一间接层，就能够与Nginx进程通讯，并获取想要的东西。
> 浏览器实际上只是在与端口通讯，端口层再把这些请求委托（delegate）或代理（proxy）给相应的web server去处理，端口的角色就是一个中间人，一个间接层。

### 再论缺省端口

现在，我们应该明白端口是必要的了。另一方面说，理论上，web服务实际上可以构建在任何端口之上，比如在本地开发的时候，用户只有你自己，那当然你可以随便挑一个端口，比如8080，只要自己知道就好或者几个人。
> 同理，其它非web的服务，比如ftp服务，也不一定说非得在21端口上等等；mysql服务的端口同样可以调整为3306之外的其它端口。

又或者说，你想提供一个服务，但只想小范围内的人知道，你可以挑一个很偏门的端口，这样一般人只输一个域名就没法访问到你的服务了。

### 端口与TCP/UDP协议

前面一直在说，什么什么3306端口，80端口，433端口，其实严格来说，端口是分TCP端口和UDP端口的，不过多数时候遇到的都是TCP端口，但TCP 80端口和UDP 80端口是不同的端口。
> UDP的80端口，包括443端口其实被保留了，目前http协议只构建在TCP协议上，当然理论上讲，在UDP上构建http也不能说就完全不行，毕竟，无论UDP还是TCP都是构建在IP协议上，总之，计算机的世界没什么是不可能的。

还有一点，对于进程间的端口通讯，实际上是对称的，也即是说，服务器的响应也是先回到一个客户端的端口上。
> 如果你用Windows 10 系统可以在 任务管理器\>性能 \>网络\>TCP连接，点击下远程端口可以按照从小到大排列，通常可以看到443的相关连接了，可以看到左边有一栏本地窗口，一个TCP连接总是有一个远程端口和一个本地端口。

当发起一个TCP连接时，客户端首先自己先随机挑选一个没有被使用的端口作为服务器响应的接收端口，比如38662，在一个TCP的包里，无论是握手包还是后续的数据包，包头部分最重要的两个字段，一个就是源端口（source port），比如38662，另一个就是目标端口（destination port），比如80，或者443。
> 可以这样看，服务器的响应也是先回到源端口，比如38662上，源端口再转给最终的进程，比如浏览器。

而对于一个IP包，同样的，包头部分最重要的两个字段，一个就是源IP（source IP）；另一个就是目标IP（destination IP）
> 而TCP包会作为IP包的数据包被打包到IP包里面，也一个IP包里面其实包含了IP+端口

IP+端口再加上端口与进程间的关联，分属两个不同主机间的进程就能通过TCP（UDP）/IP协议进行IPC。
> 当然，同一个主机间的进程也同样可以使用这套机制，但同一个主机间还可以有其他选择，这个具体看操作系统支持，而TCP/IP属于广泛应用的标准协议。




